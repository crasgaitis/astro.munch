<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>

    <script>
        let scene, camera, renderer, controls;
        const noiseGen = new Noise(Math.random());
        const galaxyShapes = ["Spiral", "Elliptical", "Irregular"];

        function init() {
            // init scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls (user)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2;

            // lighting
            const light = new THREE.PointLight(0xFFFFFF, 1, 500);
            light.position.set(0, 0, 50);
            scene.add(light);

            // galaxies
            createGalaxy("Spiral", 10, 0.5, 50, new THREE.Vector3(-30, 0, 0));
            createGalaxy("Elliptical", 15, 0.8, 40, new THREE.Vector3(30, 0, 0));
            createGalaxy("Irregular", 12, 0.1, 60, new THREE.Vector3(0, 30, 0));

            // animation loop
            animate();
        }

        function fractalNoise3D(x, y, z, octaves = 4, persistence = 0.5, lacunarity = 2) {
            let amplitude = 1.0;
            let frequency = 1.0;
            let noiseSum = 0.0;
            let maxAmplitude = 0.0;

            for (let i = 0; i < octaves; i++) {
                noiseSum += amplitude * noiseGen.simplex3(x * frequency, y * frequency, z * frequency);
                maxAmplitude += amplitude;

                amplitude *= persistence;  // amplitude decreases with each octave
                frequency *= lacunarity;   // frequency increases with each octave
            }

            return noiseSum / maxAmplitude;  // normalize result to [-1,1]
        }


        function createGalaxy(shape, size, gasContent, radius, position) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            // generate galaxy particles
            for (let i = 0; i < size * 1000; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;

                let x = 0, y = 0, z = 0;

                if (shape === "Spiral") {
                    const particle_type = Math.random();
                    const spiralFactor = Math.sqrt(distance / radius);  // smoother curve
                    const spiralDensity = Math.exp(-Math.pow(distance / radius, 4));

                    const numArms = 2;
                    const armIndex = i % numArms;
                    const direction = (armIndex === 0) ? 1 : -1;  // clockwise vs counterclockwise

                    const theta = spiralFactor * Math.PI * 6 * direction;  
                    const baseAngle = (2 * Math.PI * armIndex) / numArms;  // offset between arms

                    if (particle_type > 0.7) {
                        // central bulge - denser toward the center, slightly distorted ellipsoid

                        const phi = Math.acos(2 * Math.random() - 1);  
                        const azimuth = 2 * Math.PI * Math.random();

                        // radius with higher density toward center
                        const rand = Math.random();
                        let scaledR;
                        if (rand < Math.exp(-Math.pow(distance / radius, 0.01))) {
                            scaledR = distance * 0.2 * Math.random(); 
                        } else {
                            scaledR = (distance * 0.75) * (0.3 + 0.7 * Math.random()); 
                        } 

                        const distortion = 0.1 * (Math.random() - 0.5);

                        const x_base = scaledR * Math.sin(phi) * Math.cos(azimuth);
                        const y_base = scaledR * Math.sin(phi) * Math.sin(azimuth);
                        const z_base = scaledR * 0.5 * Math.cos(phi);  // flattened z

                        x = x_base * (1 + distortion);
                        y = y_base * (1 + distortion);
                        z = z_base * (1 + distortion);
                    

                    } else {
                        // spiral arms with 3D winding and opposite rotations
                        const armRadius = distance * spiralDensity;

                        // base spiral in xy-plane
                        const xBase = armRadius * Math.cos(theta + baseAngle);
                        const yBase = armRadius * Math.sin(theta + baseAngle);

                        const perpendicularAngle = theta + Math.PI / 2;
                        const thickness = (Math.random() - 0.5) * radius / 3; 
                        const offsetX = thickness * Math.cos(perpendicularAngle);
                        const offsetY = thickness * Math.sin(perpendicularAngle);

                        // 3D winding in z
                        const windAmplitude = radius / 5;
                        const windFrequency = 5;  // number of vertical waves
                        const zSpiral = Math.sin(theta * windFrequency) * windAmplitude * spiralDensity;

                        x = (xBase + offsetX) * (1 + 0.05 * (Math.random() - 0.5));
                        y = (yBase + offsetY) * (1 + 0.05 * (Math.random() - 0.5));
                        z = zSpiral + (Math.random() - 0.5) * radius / 15 * spiralDensity;
                    }
                }
                                    
                else if (shape === "Elliptical") {
                    const ellipticityY = 0.6;
                    const ellipticityZ = 0.6;
                    const numClumps = 4;

                    if (typeof clumpCenters === "undefined") { // pre define clumpCenters
                        clumpCenters = [];
                        for (let c = 0; c < numClumps; c++) {
                            // TODO: bias this towards center
                            const r = distance * 0.85 * Math.cbrt(Math.random());
                            const angleC = Math.random() * 2 * Math.PI;
                            const phiC = Math.acos(2 * Math.random() - 1);

                            let dxC = Math.sin(phiC) * Math.cos(angleC);
                            let dyC = Math.sin(phiC) * Math.sin(angleC);
                            let dzC = Math.cos(phiC);

                            dyC *= ellipticityY;
                            dzC *= ellipticityZ;

                            clumpCenters.push({
                                x: r * dxC,
                                y: r * dyC,
                                z: r * dzC,
                            });
                        }
                    }

                    const clumpProbability = 0.1; 

                    if (Math.random() < clumpProbability) {
                        const clump = clumpCenters[Math.floor(Math.random() * clumpCenters.length)];

                        const offsetAngle = Math.random() * 2 * Math.PI;
                        const offsetPhi = Math.acos(2 * Math.random() - 1);

                        let offsetDx = Math.sin(offsetPhi) * Math.cos(offsetAngle);
                        let offsetDy = Math.sin(offsetPhi) * Math.sin(offsetAngle);
                        let offsetDz = Math.cos(offsetPhi);

                        const irregularScaleX = 0.7 + 0.6 * Math.random();
                        const irregularScaleY = 0.7 + 0.6 * Math.random();
                        const irregularScaleZ = 0.7 + 0.6 * Math.random();

                        offsetDx *= irregularScaleX;
                        offsetDy *= irregularScaleY;
                        offsetDz *= irregularScaleZ;

                        const length = Math.sqrt(offsetDx * offsetDx + offsetDy * offsetDy + offsetDz * offsetDz);
                        offsetDx /= length;
                        offsetDy /= length;
                        offsetDz /= length;

                        const clumpRadiusScale = 0.08 + Math.random() * (0.2 - 0.08);

                        const offsetRadius = radius * clumpRadiusScale * (0.5 + 0.7 * Math.random());

                        x = clump.x + offsetRadius * offsetDx;
                        y = clump.y + offsetRadius * offsetDy;
                        z = clump.z + offsetRadius * offsetDz;
                    
                    } else {

                        const alpha = 0.9;
                        let r = radius * Math.pow(Math.random(), alpha);

                        const angleB = Math.random() * 2 * Math.PI;
                        const phiB = Math.acos(2 * Math.random() - 1);

                        let dxB = Math.sin(phiB) * Math.cos(angleB);
                        let dyB = Math.sin(phiB) * Math.sin(angleB);
                        let dzB = Math.cos(phiB);

                        dyB *= ellipticityY;
                        dzB *= ellipticityZ;

                        // fractal noise parameters
                        const noiseScale = 2.0;    // aka base frequency scale
                        const octaves = 1;
                        const persistence = 0.9;
                        const lacunarity = 9.0;

                        const noiseValue = fractalNoise3D(
                            dxB * noiseScale,
                            dyB * noiseScale,
                            dzB * noiseScale,
                            octaves,
                            persistence,
                            lacunarity
                        );

                        const noiseFactor = 1 + 0.3 * noiseValue;

                        r = r * noiseFactor;

                        x = r * dxB;
                        y = r * dyB;
                        z = r * dzB;
                    }
    
                                
                } else if (shape === "Irregular") {
                    // TODO: make less perfectly spherical
                    const angle = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);

                    let dx = Math.sin(phi) * Math.cos(angle);
                    let dy = Math.sin(phi) * Math.sin(angle);
                    let dz = Math.cos(phi);

                    const noiseScale = 1.05; // tweak for finer/coarser bumps
                    const noiseValue = noiseGen.simplex3(dx * noiseScale, dy * noiseScale, dz * noiseScale);

                    const distortionStrength = 0.6;
                    const distortedRadius = (radius/2) * (1 + distortionStrength * noiseValue);

                    x = distortedRadius * dx;
                    y = distortedRadius * dy;
                    z = distortedRadius * dz;
                }

                vertices.push(x + position.x, y + position.y, z + position.z);

                const bellCurve = Math.random() * 2 - 1;
                const intensity = Math.exp(-bellCurve * bellCurve);
                const color = new THREE.Color();
                color.setHSL((gasContent + bellCurve) / 2, 1, intensity);

                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // black hole
            const blackHoleGeometry = new THREE.SphereGeometry(1, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            blackHole.position.copy(position);
            scene.add(blackHole);

            // TODO: add bulge around black hole
        }

        // animation
        function animate() {
            requestAnimationFrame(animate);

            // update controls
            controls.update();

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
