<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>

    <script>
        let scene, camera, renderer, controls;
        const noiseGen = new Noise(Math.random());
        const galaxyShapes = ["Spiral", "Elliptical", "Irregular"];

        function init() {
            // init scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls (user)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2;

            // lighting
            const light = new THREE.PointLight(0xFFFFFF, 1, 500);
            light.position.set(0, 0, 50);
            scene.add(light);

            // galaxies
            createGalaxy("Spiral", 10, 0.5, 50, new THREE.Vector3(-30, 0, 0));
            createGalaxy("Elliptical", 15, 0.8, 40, new THREE.Vector3(30, 0, 0));
            createGalaxy("Irregular", 12, 0.1, 60, new THREE.Vector3(0, 30, 0));

            // animation loop
            animate();
        }

        function createGalaxy(shape, size, gasContent, radius, position) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            // generate galaxy particles
            for (let i = 0; i < size * 1000; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;

                let x = 0, y = 0, z = 0;

        if (shape === "Spiral") {
            const particle_type = Math.random();
            const r = distance;
            const spiralFactor = Math.sqrt(r / radius);  // smoother curve
            const spiralDensity = Math.exp(-Math.pow(r / radius, 4));

            const numArms = 2;
            const armIndex = i % numArms;
            const direction = (armIndex === 0) ? 1 : -1;  // clockwise vs counterclockwise

            const theta = spiralFactor * Math.PI * 6 * direction;  
            const baseAngle = (2 * Math.PI * armIndex) / numArms;  // offset between arms

            if (particle_type > 0.7) {
                // central bulge - denser toward the center, slightly distorted ellipsoid

                const phi = Math.acos(2 * Math.random() - 1);  
                const azimuth = 2 * Math.PI * Math.random();

                // radius with higher density toward center
                const rand = Math.random();
                let scaledR;
                if (rand < Math.exp(-Math.pow(r / radius, 0.01))) {
                    scaledR = r * 0.2 * Math.random(); 
                } else {
                    scaledR = (r * 0.75) * (0.3 + 0.7 * Math.random()); 
                }

                const distortion = 0.1 * (Math.random() - 0.5);

                const x_base = scaledR * Math.sin(phi) * Math.cos(azimuth);
                const y_base = scaledR * Math.sin(phi) * Math.sin(azimuth);
                const z_base = scaledR * 0.5 * Math.cos(phi);  // flattened z

                x = x_base * (1 + distortion);
                y = y_base * (1 + distortion);
                z = z_base * (1 + distortion);
            

            } else {
                // spiral arms with 3D winding and opposite rotations
                const armRadius = r * spiralDensity;

                // base spiral in xy-plane
                const xBase = armRadius * Math.cos(theta + baseAngle);
                const yBase = armRadius * Math.sin(theta + baseAngle);

                const perpendicularAngle = theta + Math.PI / 2;
                const thickness = (Math.random() - 0.5) * radius / 3; 
                const offsetX = thickness * Math.cos(perpendicularAngle);
                const offsetY = thickness * Math.sin(perpendicularAngle);

                // 3D winding in z
                const windAmplitude = radius / 5;
                const windFrequency = 5;  // number of vertical waves
                const zSpiral = Math.sin(theta * windFrequency) * windAmplitude * spiralDensity;

                x = (xBase + offsetX) * (1 + 0.05 * (Math.random() - 0.5));
                y = (yBase + offsetY) * (1 + 0.05 * (Math.random() - 0.5));
                z = zSpiral + (Math.random() - 0.5) * radius / 15 * spiralDensity;
            }
                                                

                } else if (shape === "Elliptical") {
                    // TODO: add in density profile
                    x = distance * Math.cos(angle);
                    y = distance * Math.sin(angle) * 0.6;  
                    z = (Math.random() - 0.5) * radius / 3;  
                
                } else if (shape === "Irregular") {
                    // TODO: make less perfectly spherical
                    const angle = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);

                    let dx = Math.sin(phi) * Math.cos(angle);
                    let dy = Math.sin(phi) * Math.sin(angle);
                    let dz = Math.cos(phi);

                    const noiseScale = 1.05; // tweak for finer/coarser bumps
                    const noiseValue = noiseGen.simplex3(dx * noiseScale, dy * noiseScale, dz * noiseScale);

                    const distortionStrength = 0.6;
                    const distortedRadius = (radius/2) * (1 + distortionStrength * noiseValue);

                    x = distortedRadius * dx;
                    y = distortedRadius * dy;
                    z = distortedRadius * dz;
                }

                vertices.push(x + position.x, y + position.y, z + position.z);

                const bellCurve = Math.random() * 2 - 1;
                const intensity = Math.exp(-bellCurve * bellCurve);
                const color = new THREE.Color();
                color.setHSL((gasContent + bellCurve) / 2, 1, intensity);

                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // black hole
            const blackHoleGeometry = new THREE.SphereGeometry(1, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            blackHole.position.copy(position);
            scene.add(blackHole);

            // TODO: add bulge around black hole
        }

        // animation
        function animate() {
            requestAnimationFrame(animate);

            // update controls
            controls.update();

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
